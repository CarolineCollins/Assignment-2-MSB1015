---
title: "pls vignette"
author: "Caroline Collins 6192527"
date: "26 September 2019"
output: html_document
---
Following the vignette at
https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
There are some example datasets loaded in the pls package.
yarn 
A data set with 28 near-infrared spectra (NIR) of PET yarns, measured at 268 wavelengths, as predictors, and density as response (density) [20]. 
The data set also includes
a logical variable train which can be used to split the data into a training data set of
size 21 and test data set of size 7. See ?yarn for details.
oliveoil
A data set with 5 quality measurements (chemical) and 6 panel sensory panel
variables (sensory) made on 16 olive oil samples [15]. See ?oliveoil for details.
gasoline 
A data set consisting of octane number (octane) and NIR spectra (NIR) of 60 gasoline samples [10]. Each NIR spectrum consists of 401 diffuse reflectance measurements
from 900 to 1700 nm. See ?gasoline for details.

```{r}
library(pls)
data(yarn)
data(oliveoil)
data(gasoline)

```
We first divide the data set into train and test data sets:

```{r}
gasTrain <- gasoline[1:50,]
gasTest <- gasoline[51:60,]
```
A typical way of fitting a PLSR model is
```{r}
gas1 <- plsr(octane ~ NIR, ncomp = 10, data = gasTrain, validation = "LOO")
```
This fits a model with 10 components, 
and includes leave-one-out (LOO) cross-validated predictions. 
We can get an overview of the fit and validation results with the summary method:
```{r}
summary(gas1)
```
The validation results here are Root Mean Squared Error of Prediction (RMSEP). 
There are 2 cross-validation estimates: CV is the ordinary CV estimate, and adjCV is a bias-corrected CV estimate
[ref: Bjørn-Helge Mevik and Henrik Ren´e Cederkvist. Mean squared error of prediction
(MSEP) estimates for principal component regression (PCR) and partial least squares
regression (PLSR). Journal of Chemometrics, 18(9):422-429, 2004.]. 
For a LOO CV, there is virtually no difference between adjCV and CV.
It is often simpler to judge the RMSEPs by plotting them:
```{r}
plot(RMSEP(gas1), legendpos = "topright")

```
This "elbow plot" plots the estimated RMSEPs as functions of the number of components (Figure 2).
The legendpos argument adds a legend at the indicated position. 
Two components seem to be enough to give a good RMSEP of 0.297. 
As mentioned in the introduction, the main practical difference between PCR and PLSR is that PCR often needs more components than PLSR to achieve the same prediction error. 
On this data set, PCR would need three components to achieve the same RMSEP.
====

Once the number of components has been chosen, one can inspect different aspects of the
fit by plotting predictions, scores, loadings, etc. 

The default plot is a prediction plot:
```{r}
plot(gas1, ncomp = 2, asp = 1, line = TRUE)
```
This shows the cross-validated predictions with two components versus measured values, an aspect ratio of 1, and a target line. 
The points follow
the target line and there is no indication of a curvature or other anomalies.
=====

Other plottypes can be selected with the plotttype argument. The following code gives a pairwise plot of the score values for the three first components.
Score plots are often used to look for patterns, groups or outliers in the data. (For instance,plotting the two first components for a model built on the yarn dataset clearly indicates theexperimental design of that data.) In this example, there is no clear indication of grouping or outliers. The numbers in parentheses after the component labels are the relative amount of X variance explained by each component. 


```{r}
plot(gas1, plottype = "scores", comps = 1:3)
```
The explained variances can be extracted explicitly with
```{r}
explvar(gas1)

```
The loading plot is much used for interpretation purposes, for instance to look
for known spectral peaks or profiles. The labels = "numbers" argument makes the plot function try to interpret the variable names as numbers, and use them as x axis labels.
```{r}
plot(gas1, "loadings", comps = 1:2, legendpos = "topleft",  labels = "numbers", xlab = "nm")
abline(h = 0)
```

A fitted model is often used to predict the response values of new observations. 
The following predicts responses for the 10 observations in gasTest, using 2 components:
```{r}
predict(gas1, ncomp = 2, newdata = gasTest)

```
Because we know the true response values for these samples, we can calculate the test set
RMSEP:
```{r}
RMSEP(gas1, newdata = gasTest)
```
=============================
##Formulas and data frames

The pls package has a formula interface that works like the formula interface in R's standard lm functions, in most ways. 
This section gives a short description of formulas and dataframes as they apply to pls. More information on formulas can be found in the lm help file,
in Chapter 11 of 'An Introduction to R', and in Chapter 2 of 'The White Book' [ref:John M. Chambers and Trevor J. Hastie. Statistical Models in S. Chapman & Hall,
London, 1992.]. 
Formulas
=======
A formula consists of a left hand side (lhs), a tilde (~), and a right hand side (rhs).
The lhs consists of a single term, representing the response(s). 
The rhs consists of one or more terms separated by +, representing the regressor(s).
The intercept is handled automatically and doesn't need to be specified.
The terms might be a matrix, a numeric vector or a factor (a factor should not be used
as the response).
If the response term is a matrix, a multi-response model is fit.
In pls, the RHS quite often consists of a single term, representing a matrix regressor: 
y ~ X.
